#!/usr/bin/env python3
"""Module for scanning targets for known vulnerabilities using CVE database."""

import logging
import json
import os
import re
import requests
import validators
from urllib.parse import urlparse
from datetime import datetime, timedelta

# Set up logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Cache directory for vulnerability data
CACHE_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'cache')
os.makedirs(CACHE_DIR, exist_ok=True)

# NVD API endpoint
NVD_API_BASE = "https://services.nvd.nist.gov/rest/json/cves/2.0"

def scan_for_vulnerabilities(target, scan_depth='standard'):
    """
    Scan a target for known vulnerabilities using CVE database.
    
    Args:
        target (str): The URL or domain to scan
        scan_depth (str): Scan depth - 'light', 'standard', or 'deep'
        
    Returns:
        dict: Vulnerability scan results
    """
    logger.debug(f"Starting vulnerability scan on {target} with {scan_depth} depth")
    
    # Validate target
    if not validators.url(target) and not validators.domain(target):
        # Try to convert to URL if it's a domain
        if validators.domain(target):
            target = f"https://{target}"
        else:
            return {
                "error": "Invalid target. Please provide a valid URL or domain.",
                "target": target
            }
    
    # Normalize target
    parsed_url = urlparse(target)
    domain = parsed_url.netloc
    
    # Initialize results
    results = {
        "target": target,
        "domain": domain,
        "scan_timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "scan_depth": scan_depth,
        "vulnerabilities": {
            "critical": [],
            "high": [],
            "medium": [],
            "low": []
        },
        "software_detected": {},
        "summary": {
            "total_vulnerabilities": 0,
            "critical_count": 0,
            "high_count": 0,
            "medium_count": 0,
            "low_count": 0
        },
        "remediation_suggestions": []
    }
    
    try:
        # Detect software and technologies
        software_info = detect_software(target)
        results["software_detected"] = software_info
        
        # For each detected software, check for known vulnerabilities
        for software_name, versions in software_info.items():
            if not versions:
                continue
                
            for version_info in versions:
                version = version_info.get("version", "")
                if not version:
                    continue
                    
                # Query NVD for vulnerabilities
                vulnerabilities = query_nvd_for_cves(software_name, version)
                
                # Process and categorize vulnerabilities
                process_vulnerabilities(vulnerabilities, results, software_name, version)
        
        # Generate remediation suggestions
        results["remediation_suggestions"] = generate_remediation_suggestions(results["vulnerabilities"])
        
        # Update summary counts
        results["summary"]["critical_count"] = len(results["vulnerabilities"]["critical"])
        results["summary"]["high_count"] = len(results["vulnerabilities"]["high"])
        results["summary"]["medium_count"] = len(results["vulnerabilities"]["medium"])
        results["summary"]["low_count"] = len(results["vulnerabilities"]["low"])
        results["summary"]["total_vulnerabilities"] = (
            results["summary"]["critical_count"] +
            results["summary"]["high_count"] +
            results["summary"]["medium_count"] +
            results["summary"]["low_count"]
        )
        
    except Exception as e:
        logger.error(f"Error during vulnerability scan: {str(e)}")
        results["error"] = f"Scan error: {str(e)}"
    
    return results

def detect_software(target):
    """
    Detect software and versions from the target.
    
    Args:
        target (str): The URL to analyze
        
    Returns:
        dict: Detected software and their versions
    """
    software_info = {}
    
    try:
        # Request the target URL
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        }
        response = requests.get(target, headers=headers, timeout=10)
        
        # Check response headers for server info
        server = response.headers.get("Server", "")
        if server:
            components = server.split()
            for component in components:
                if "/" in component:
                    name, version = component.split("/", 1)
                    software_info[name.lower()] = [{"version": version, "confidence": "high"}]
        
        # Check for other common headers
        tech_headers = {
            "X-Powered-By": "backend",
            "X-AspNet-Version": "asp.net",
            "X-AspNetMvc-Version": "asp.net mvc"
        }
        
        for header, tech_type in tech_headers.items():
            if header in response.headers:
                value = response.headers[header]
                if "/" in value:
                    name, version = value.split("/", 1)
                    software_info[name.lower()] = [{"version": version, "confidence": "high"}]
                else:
                    software_info[tech_type] = [{"version": value, "confidence": "high"}]
        
        # Check HTML content for common technology signatures
        html_content = response.text
        
        # WordPress detection
        if "wp-content" in html_content or "wp-includes" in html_content:
            # Try to extract version from meta tags
            wp_version_match = re.search(r'<meta\s+name="generator"\s+content="WordPress\s+([0-9.]+)"', html_content)
            if wp_version_match:
                version = wp_version_match.group(1)
                software_info["wordpress"] = [{"version": version, "confidence": "high"}]
            else:
                software_info["wordpress"] = [{"version": "unknown", "confidence": "medium"}]
        
        # Drupal detection
        if "Drupal.settings" in html_content:
            drupal_version_match = re.search(r'<meta\s+name="Generator"\s+content="Drupal\s+([0-9.]+)"', html_content)
            if drupal_version_match:
                version = drupal_version_match.group(1)
                software_info["drupal"] = [{"version": version, "confidence": "high"}]
            else:
                software_info["drupal"] = [{"version": "unknown", "confidence": "medium"}]
        
        # jQuery detection
        jquery_match = re.search(r'jquery[.-]([0-9.]+)\.min\.js', html_content, re.IGNORECASE)
        if jquery_match:
            version = jquery_match.group(1)
            software_info["jquery"] = [{"version": version, "confidence": "medium"}]
        
        # Bootstrap detection
        bootstrap_match = re.search(r'bootstrap[.-]([0-9.]+)\.min\.(js|css)', html_content, re.IGNORECASE)
        if bootstrap_match:
            version = bootstrap_match.group(1)
            software_info["bootstrap"] = [{"version": version, "confidence": "medium"}]
            
    except Exception as e:
        logger.error(f"Error detecting software: {str(e)}")
    
    return software_info

def query_nvd_for_cves(software_name, version):
    """
    Query the NVD database for CVEs related to the specified software and version.
    
    Args:
        software_name (str): The name of the software
        version (str): The version of the software
        
    Returns:
        list: CVE entries for the software
    """
    # Check cache first
    cache_file = os.path.join(CACHE_DIR, f"{software_name}_{version}_cves.json")
    cache_valid = False
    
    if os.path.exists(cache_file):
        try:
            # Check if cache is still valid (less than 24 hours old)
            file_mod_time = datetime.fromtimestamp(os.path.getmtime(cache_file))
            if datetime.now() - file_mod_time < timedelta(hours=24):
                cache_valid = True
                with open(cache_file, 'r') as f:
                    return json.load(f)
        except Exception as e:
            logger.warning(f"Error reading cache: {str(e)}")
    
    vulnerabilities = []
    
    try:
        # Construct API query
        # For real implementation, we would use the NVD API with proper keyword search
        # For this example, we're using a simplified approach
        params = {
            "keywordSearch": f"{software_name} {version}",
            "resultsPerPage": 50
        }
        
        response = requests.get(NVD_API_BASE, params=params, timeout=15)
        
        if response.status_code == 200:
            data = response.json()
            if "vulnerabilities" in data:
                for vuln in data["vulnerabilities"]:
                    if "cve" in vuln:
                        vulnerabilities.append(vuln["cve"])
            
            # Cache the results
            with open(cache_file, 'w') as f:
                json.dump(vulnerabilities, f)
        else:
            logger.warning(f"NVD API returned status code {response.status_code}")
            
    except Exception as e:
        logger.error(f"Error querying NVD API: {str(e)}")
    
    return vulnerabilities

def process_vulnerabilities(vulnerabilities, results, software_name, version):
    """
    Process and categorize vulnerabilities by severity.
    
    Args:
        vulnerabilities (list): CVE entries
        results (dict): The results dictionary to update
        software_name (str): The name of the software
        version (str): The version of the software
    """
    for vuln in vulnerabilities:
        try:
            # Extract CVE ID
            cve_id = vuln.get("id", "Unknown")
            
            # Extract description
            description = "No description available"
            if "descriptions" in vuln:
                for desc in vuln["descriptions"]:
                    if desc.get("lang") == "en":
                        description = desc.get("value", "No description available")
                        break
            
            # Extract CVSS score and severity
            cvss_score = 0
            severity = "low"
            
            if "metrics" in vuln:
                if "cvssMetricV31" in vuln["metrics"]:
                    cvss_data = vuln["metrics"]["cvssMetricV31"][0]
                    cvss_score = cvss_data.get("cvssData", {}).get("baseScore", 0)
                    severity = cvss_data.get("cvssData", {}).get("baseSeverity", "").lower()
                elif "cvssMetricV30" in vuln["metrics"]:
                    cvss_data = vuln["metrics"]["cvssMetricV30"][0]
                    cvss_score = cvss_data.get("cvssData", {}).get("baseScore", 0)
                    severity = cvss_data.get("cvssData", {}).get("baseSeverity", "").lower()
                elif "cvssMetricV2" in vuln["metrics"]:
                    cvss_data = vuln["metrics"]["cvssMetricV2"][0]
                    cvss_score = cvss_data.get("cvssData", {}).get("baseScore", 0)
                    # Convert V2 score to severity
                    if cvss_score >= 9.0:
                        severity = "critical"
                    elif cvss_score >= 7.0:
                        severity = "high"
                    elif cvss_score >= 4.0:
                        severity = "medium"
                    else:
                        severity = "low"
            
            # Create vulnerability entry
            vulnerability_entry = {
                "cve_id": cve_id,
                "description": description,
                "cvss_score": cvss_score,
                "severity": severity,
                "software": software_name,
                "version": version,
                "published": vuln.get("published", ""),
                "last_modified": vuln.get("lastModified", "")
            }
            
            # Add to appropriate severity category
            if severity == "critical":
                results["vulnerabilities"]["critical"].append(vulnerability_entry)
            elif severity == "high":
                results["vulnerabilities"]["high"].append(vulnerability_entry)
            elif severity == "medium":
                results["vulnerabilities"]["medium"].append(vulnerability_entry)
            else:
                results["vulnerabilities"]["low"].append(vulnerability_entry)
                
        except Exception as e:
            logger.error(f"Error processing vulnerability: {str(e)}")

def generate_remediation_suggestions(vulnerabilities):
    """
    Generate remediation suggestions based on identified vulnerabilities.
    
    Args:
        vulnerabilities (dict): Categorized vulnerabilities
        
    Returns:
        list: Remediation suggestions
    """
    suggestions = []
    
    # Process critical vulnerabilities first
    if vulnerabilities["critical"]:
        suggestions.append({
            "priority": "Critical",
            "action": "Immediate patching required",
            "description": "Critical vulnerabilities were detected that require immediate attention. Update the following software components as soon as possible:"
        })
        
        # Group by software
        software_versions = {}
        for vuln in vulnerabilities["critical"]:
            software = vuln["software"]
            if software not in software_versions:
                software_versions[software] = set()
            software_versions[software].add(vuln["version"])
            
        for software, versions in software_versions.items():
            versions_str = ", ".join(versions)
            suggestions.append({
                "priority": "Critical",
                "action": f"Update {software}",
                "description": f"Update {software} (current versions: {versions_str}) to the latest secure version to address critical vulnerabilities"
            })
    
    # Process high vulnerabilities
    if vulnerabilities["high"]:
        suggestions.append({
            "priority": "High",
            "action": "Prioritize patching",
            "description": "High severity vulnerabilities were detected. Schedule updates for the following components within the next maintenance window:"
        })
        
        # Group by software
        software_versions = {}
        for vuln in vulnerabilities["high"]:
            software = vuln["software"]
            if software not in software_versions:
                software_versions[software] = set()
            software_versions[software].add(vuln["version"])
            
        for software, versions in software_versions.items():
            versions_str = ", ".join(versions)
            suggestions.append({
                "priority": "High",
                "action": f"Update {software}",
                "description": f"Update {software} (current versions: {versions_str}) to address high severity vulnerabilities"
            })
    
    # General recommendations
    suggestions.append({
        "priority": "General",
        "action": "Implement security best practices",
        "description": "Ensure regular security patching is in place for all software components. Consider implementing a vulnerability management program to track and remediate security issues."
    })
    
    return suggestions

if __name__ == "__main__":
    # Example usage
    results = scan_for_vulnerabilities("https://example.com")
    print(json.dumps(results, indent=2))